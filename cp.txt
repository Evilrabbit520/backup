{
    "location": [
        {
            "directory": "./node_modules/@angular/cli/lib/",
            "fullReserves": 1,
            "incrementalReserves": 1,
            "lastBakTime": "2025-01-01",
            "listFiles": {
                "name": {
                "fileName": "a.txt",
                "fileSize(Byte)": "1",
                "creation": "2025-01-01",
                "modified": "2025-01-01"
                    }
                }
            }
    ]
}


#include <iostream>
#include <filesystem>
#include <fstream>
#include <chrono>
#include <ctime>
#include <vector>
#include <algorithm>

// 获取当前时间戳
std::string getCurrentTimestamp()
{
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y%m%d_%H%M%S");
    return ss.str();
}

// 获取文件的最后修改时间
std::time_t getFileModTime(const std::filesystem::path &filePath)
{
    auto ftime = std::filesystem::last_write_time(filePath);
    // 手动转换时间点
    auto duration = ftime.time_since_epoch();
    auto sys_duration = std::chrono::duration_cast<std::chrono::system_clock::duration>(duration);
    return std::chrono::system_clock::to_time_t(
        std::chrono::system_clock::time_point(sys_duration));
}

// 读取备份记录文件
bool readBackupRecord(const std::filesystem::path &recordFile,
                      std::vector<std::pair<std::string, std::time_t>> &records)
{
    std::ifstream in(recordFile);
    if (!in)
        return false;

    std::string line, filename;
    std::time_t timestamp;
    while (std::getline(in, line))
    {
        size_t pos = line.find_last_of(' ');
        if (pos != std::string::npos)
        {
            filename = line.substr(0, pos);
            timestamp = std::stol(line.substr(pos + 1));
            records.emplace_back(filename, timestamp);
        }
    }
    return true;
}

// 写入备份记录文件
void writeBackupRecord(const std::filesystem::path &recordFile,
                       const std::vector<std::pair<std::string, std::time_t>> &records)
{
    std::ofstream out(recordFile);
    for (const auto &[filename, timestamp] : records)
    {
        out << filename << " " << timestamp << "\n";
    }
}

// 备份操作
void performBackup(const std::filesystem::path &sourceDir, const std::filesystem::path &destDir,
                   const std::vector<std::filesystem::path> &filesToBackup)
{
    for (const auto &file : filesToBackup)
    {
        std::filesystem::path relativePath = std::filesystem::relative(file, sourceDir);
        std::filesystem::path destPath = destDir / relativePath;

        // 创建目标目录结构
        std::filesystem::create_directories(destPath.parent_path());

        // 复制文件
        std::filesystem::copy(file, destPath, std::filesystem::copy_options::overwrite_existing);
    }
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        std::cerr << "Usage: " << argv[0] << " \"source_directory\" \"destination_directory\"\n";
        return 1;
    }

    std::filesystem::path sourceDir = std::filesystem::absolute(argv[1]);
    std::filesystem::path destDir = std::filesystem::absolute(argv[2]);

    if (!std::filesystem::exists(sourceDir) || !std::filesystem::is_directory(sourceDir))
    {
        std::cerr << "Error：源目录不存在或不是目录(Error: Source directory does not exist or is not a directory)\n";
        return 1;
    }

    // 创建备份记录文件名
    std::string timestamp = getCurrentTimestamp();
    std::filesystem::path recordFile = sourceDir / ("backup_timestamp.btd");

    // 询问备份类型
    std::cout << "Select backup type:\n";
    std::cout << "1. Full backup\n";
    std::cout << "2. Incremental backup\n";
    std::cout << "Your choice (1/2): ";

    int choice;
    std::cin >> choice;
    if (choice != 1 && choice != 2)
    {
        std::cerr << "Invalid choice\n";
        return 1;
    }

    // 收集需要备份的文件
    std::vector<std::filesystem::path> filesToBackup;
    std::vector<std::pair<std::string, std::time_t>> newRecords;

    // goto full_backup
    full_backup:

    if (choice == 1)
    { // 全备份
        for (const auto &entry : std::filesystem::recursive_directory_iterator(sourceDir))
        {
            if (entry.is_regular_file() && entry.path().filename() != "backup_timestamp.btd")
            {
                filesToBackup.push_back(entry.path());
                newRecords.emplace_back(
                    std::filesystem::relative(entry.path(), sourceDir).string(),
                    getFileModTime(entry.path()));
            }
        }
    }
    else
    { // 增量备份
        // 查找最新的备份记录文件
        std::filesystem::path latestRecordFile;
        std::time_t latestTime = 0;

        for (const auto &entry : std::filesystem::directory_iterator(sourceDir))
        {
            if (entry.path().extension() == ".btd")
            {
                std::string filename = entry.path().filename().string();
                if (filename.substr(0, 7) == "backup_")
                {
                    auto modTime = getFileModTime(entry.path());
                    if (modTime > latestTime)
                    {
                        latestTime = modTime;
                        latestRecordFile = entry.path();
                    }
                }
            }
        }
        if (latestRecordFile.empty())
        {
            std::cout << "未找到以前的备份，而是执行完整备份(No previous backup found, performing full backup instead)\n";
            choice = 1;
            goto full_backup;
        }

        // 读取之前的备份记录
        std::vector<std::pair<std::string, std::time_t>> oldRecords;
        if (!readBackupRecord(latestRecordFile, oldRecords))
        {
            std::cerr << "读取备份记录文件时出错(Error reading backup record file)\n";
            return 1;
        }
        // 比较文件修改时间
        std::unordered_map<std::string, std::time_t> oldRecordMap(
            oldRecords.begin(), oldRecords.end());

        for (const auto &entry : std::filesystem::recursive_directory_iterator(sourceDir))
        {
            if (entry.is_regular_file() && entry.path().filename() != "backup_timestamp.btd")
            {
                auto relPath = std::filesystem::relative(entry.path(), sourceDir).string();
                auto modTime = getFileModTime(entry.path());

                newRecords.emplace_back(relPath, modTime);

                auto it = oldRecordMap.find(relPath);
                if (it == oldRecordMap.end() || it->second < modTime)
                {
                    filesToBackup.push_back(entry.path());
                }
            }
        }
    }

    // 显示将要备份的文件列表
    std::cout << "\nFiles to be backed up (" << filesToBackup.size() << "):\n";
    for (const auto &file : filesToBackup)
    {
        std::cout << "  " << file << "\n";
    }

    // 确认备份
    std::cout << "\nProceed with backup? (y/n): ";
    char confirm;
    std::cin >> confirm;

    if (confirm != 'y' && confirm != 'Y')
    {
        std::cout << "Backup cancelled\n";
        return 0;
    }

    // 执行备份
    performBackup(sourceDir, destDir, filesToBackup);

    // 写入备份记录
    writeBackupRecord(recordFile, newRecords);

    std::cout << "Backup completed successfully\n";
    return 0;
}